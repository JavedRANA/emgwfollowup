"""
Generate the grid of tiles on the sky putting the first tile at the
center of the GW localization. The tile is the FOV of the telescope. All the telescope
details are taken as input.

print summary:
    # center of the localization
    # number of tiles to cover specified probability contoure
    # the covered probability
    # area of the contoure

The output is saved as output.csv file.
"""

import argparse

parser = argparse.ArgumentParser()
parser.add_argument(
    'input', metavar='INPUT.fits[.gz]', nargs='+',
    help='Name of input file')
parser.add_argument(
    '-o', '--output', metavar='output.csv', type=argparse.FileType('wb'),
    default='-', help='Name of output file [default: stdout]')
parser.add_argument(
    '--contoure', type=float,
    default=0.95, help='Probability contoure [default: %(default)s]')
parser.add_argument(
    '--observetory-lat', type=float,
    default=19.1, help='Latitude of the observetory [default: %(default)s]')
parser.add_argument(
    '--observetory-lon', type=float,
    default=73.6, help='Longitude of the Observetory [default: %(default)s]')
parser.add_argument(
    '--fov-width', type=float,
    default=3.2, help='Width of the FOV [default: %(default)s]')
parser.add_argument(
    '--fov-hight', type=float,
    default=2.7, help='Hight of the FOV [default: %(default)s]')
parser.add_argument(
    '--altitude', type=float,
    default=1000, help='Altitude of the Telescope [default: %(default)s]')
parser.add_argument(
    '--horizon', type=float,
    default=25., help='Visibility horizon for the Telescope [default: %(default)s]')
parser.add_argument(
    '--twilight', type=float,
    default=-12., help='Observation starts, when Sun goes belowtwilight [default: %(default)s]')
parser.add_argument(
    '--start-ra', type=float,
    default=0., help='RA of the starting point of the grid [default: %(default)s]')
parser.add_argument(
    '--start-dec', type=float,
    default=0., help='Dec of the starting point of the grid [default: %(default)s]')
parser.add_argument(
    '--alpha', type=float,
    default=0., help='Position-Angle of the FOV [default: %(default)s]')
parser.add_argument(
    '--gridplot',
    default=False, help='Make the sky plot [default: %(default)s]')
opts = parser.parse_args()


# Python modules
import numpy as np
import healpy as hp
from astropy.table import Table, Column
from astropy.io import ascii


class Observetory:
    """The detail of the Ovservetory"""

    fov_w = opts.fov_width
    fov_h = opts.fov_hight
    lat = opts.observetory_lat
    lon = opts.observetory_lon
    altitude = opts.altitude
    horizon = opts.horizon
    twilight = opts.twilight


class Patch:
    """The probability distribution of the GW sky localization
    Read the healpix file generated by GW detectros"""

    pixProb = hp.read_map(opts.input[0])
    nside = hp.npix2nside(len(pixProb))
    pix_area = hp.nside2pixarea(nside, degrees=True)
    order = np.argsort(-pixProb)
    mask = np.cumsum(-np.sort(-pixProb)) <= opts.contoure
    prob = pixProb[order][mask]
    theta, phi = hp.pix2ang(nside, np.arange(len(pixProb))[order][mask], nest=False)
    ra, dec = np.rad2deg(phi), np.rad2deg(np.pi/2.0 - theta)
    center_ra, center_dec = ra[np.argmax(prob)], dec[np.argmax(prob)]		


# The observetory details
telescope = Observetory()


def sphtri(point_dec, l, d, alpha):
    """Spherical trigometry"""

    h = np.arcsin(np.tan(alpha)*np.sin(d))
    a = (l-h)
    f = np.arcsin(np.sin(d)*np.sin(alpha)*np.tan(alpha))
    g = np.arcsin(np.sin(d)*np.cos(alpha))
    c = np.pi/2. - point_dec - (g+f)
    ee = np.arccos(np.cos(a)*np.cos(c) + np.sin(a)*np.sin(c)*np.cos(0.5*np.pi-alpha))
    zz = np.arcsin(np.sin(a)*np.sin(0.5*np.pi-alpha)/np.sin(ee))
    return ee, zz


def tileCorners(tile_center, fov_w, fov_h, alpha):
    """Return the four Corners of a tile"""

    width = 0.5 * fov_w * np.pi / 180.
    tile_corners = []
    for i1 in [1, -1]:
	hight = i1 * 0.5 * fov_h * np.pi / 180.
	for i2 in [1, -1]:
            ee, zz = sphtri(tile_center[1]*np.pi/180., width, hight, -i2*alpha)
            tile_corners.append([tile_center[0]-i2*zz*180.0/np.pi, 90.-ee*180.0/np.pi])
            # tile_corner[left_up, right_up, left_dwn, right_dwn]
    return tile_corners


def nexTileCenter(tile_center, fov_w, alpha):
    """return the center of the next tile"""

    fov_width = fov_w*np.pi/180.
    ee, zz = sphtri(tile_center[1]*np.pi/180., fov_width, 0., alpha)	
    return tile_center[0] + zz*180.0/np.pi, tile_center[1] + np.arcsin(np.sin(alpha)*np.sin(fov_width))*(180.0/np.pi)


def gridTilesCenter(patch_center_ra, patch_center_dec, alpha):
    """Make the grid, calculating centers of the tiles for the telescope"""

    if opts.start_ra: patch_center_ra = opts.start_ra
    if opts.start_dec: patch_center_dec = opts.start_dec
    print "Center of the localization: ra= %f  dec= %f" %(patch_center_ra, patch_center_dec)

    # Starts from 0 ra
    tile_center = [0., patch_center_dec]
    tiles_center = []
    # For the upper(1) and lower(-1) part of the patch
    for ul in [1, -1]:
        # Not to double count with the starting dec
        if ul==-1: tile_center = [0., patch_center_dec - telescope.fov_h]
        while (abs(tile_center[1]) <= 90.):
            # For the left(-1) and right(1) part of the patch
            for lr in[1, -1]:
                if lr==-1: 
                    tile_center = [0., tile_center[1]]
                    tile_center = nexTileCenter(tile_center, lr * telescope.fov_w, alpha)
                while (abs(tile_center[0]) <= 180.):
                    # Add the patch center ra with tile center ra
                    tiles_center.append([tile_center[0] + patch_center_ra, tile_center[1]])
                    tile_center = nexTileCenter(tile_center, lr * telescope.fov_w, alpha)
            # Go to next dec line
            tile_center = [0., tile_center[1] + (ul * telescope.fov_h)]
    return tiles_center
            

def gridTilesCorner(grid, allsky=False):
    """Calculate the Corners of the tiles of the grid"""

    if grid and not allsky:
        tiles_center = [[ra, dec] for ra, dec in zip(grid['ra'], grid['dec'])]
    if allsky: tiles_center = gridTilesCenter(opts.alpha)
    return [tileCorners(tile_center, telescope.fov_w, telescope.fov_h, opts.alpha) for tile_center in tiles_center]


def pixInTile(tile_corners, nside):
    """Return the pixels inside a Tile."""

    ra = np.array([tile_corners[0][0], tile_corners[1][0], tile_corners[3][0], tile_corners[2][0]])
    dec = np.array([tile_corners[0][1], tile_corners[1][1], tile_corners[3][1], tile_corners[2][1]])
    phi, theta = ra*np.pi/180., (90. - dec)*np.pi/180.
    vertices = hp.ang2vec(theta, phi) 
    pixIn = hp.query_polygon(nside, vertices, inclusive=False, nest=False)
    return pixIn


def tileProb(pix_prob, tile_corners, nside):
    """Return the probability in a Tile."""

    pix_in_tile = pixInTile(tile_corners, nside)
    tile_prob = sum(pix_prob[pix_in_tile])
    pix_prob[pix_in_tile] = 0.
    return tile_prob


def gridding():
    """Make the grid of tiles with probability"""

    # the patch details
    patch = Patch()

    tiles_center = gridTilesCenter(patch.center_ra, patch.center_dec, opts.alpha)
    tiles_prob = []
    tiles_center_ra = []
    tiles_center_dec = []
    pix_prob = patch.pixProb.copy()
    for tile_center in tiles_center:
        tiles_center_ra.append(tile_center[0])
        tiles_center_dec.append(tile_center[1])
        tile_corners = tileCorners(tile_center, telescope.fov_w, telescope.fov_h, opts.alpha)
        tiles_prob.append(tileProb(pix_prob, tile_corners, patch.nside))
    
    #skyplot(patch.pixProb, (90.-np.array(tiles_center_dec))*np.pi/180, np.array(tiles_center_ra)*np.pi/180)
    grid = Table({'tile_id': range(len(tiles_prob)), \
            'ra': tiles_center_ra, 'dec': tiles_center_dec, \
            'prob': tiles_prob}, names= ['tile_id', 'ra', 'dec', 'prob'])
    grid.sort('prob')
    grid.reverse()
    grid = grid[np.cumsum(grid['prob']) <= opts.contoure]
    grid['tile_id'] = range(len(grid))

    # print the summary    
    print "Number of tile to cover %f probability is %d" %(opts.contoure, len(grid))
    print "The probability in %d tiles is %f" %(len(grid), sum(grid['prob']))
    print "Area of the %f contoure is %f sq.deg." %(opts.contoure, len(patch.prob) * patch.pix_area)
    ascii.write(grid, opts.output, format='csv', fast_writer=False, overwrite=True)
    return grid

gridding()
